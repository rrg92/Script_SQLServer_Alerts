/*
	Main alert procedure core!
	This get alerts and run it.
	TODO:
		- Alert last run!
*/
ALTER PROCEDURE core.RunAlerts(
	@SleepInterval varchar(15) = NULL
	,@Debug bit = 0
	,@CatchErrors bit = 1
)
AS
	-- Iterate over alert list and run it!
	DECLARE
		@NextAlertNum int = 0
		,@RowCount int = 0
		,@AlertID	int
		,@AlertName varchar(200)
		,@AlertProc sysname
		,@AlertFreq varchar(100)
		,@AlertLastRun varchar(100)
		,@AlertLastResult int

		,@AlertFreqSec int

		,@TmpQuery nvarchar(2000)
		,@TmpString nvarchar(max)
		,@AlertResult int
		,@AlertInput XML
		,@AlertOutput XML
		,@ErrorXML nvarchar(max)

		,@OutputProc sysname
	;

	WHILE 1 = 1
	BEGIN
		SET @NextAlertNum = 0;

		-- Main loop alerts!
		WHILE 1 = 1
		BEGIN
			SET @NextAlertNum += 1;
			SET @AlertID		= NULL
			SET @AlertProc		= NULL
			SET @AlertResult	= NULL

			-- Get next Alert!
			SELECT TOP 1 
				@AlertID	= A.AlertID
				,@AlertName	= A.AlertName
				,@AlertProc	= A.ProcedureName
				,@AlertFreq = A.Frequency
			FROM
				dbo.Alerts A 
			WHERE 
				AlertID >= @NextAlertNum 
				AND
				A.Enabled = 1
			ORDER BY AlertID;

			-- If no more alerts, end loop!
			IF @AlertID IS NULL 
			BEGIN
				IF @Debug = 1 RAISERROR('No more alerts. NextNum:%d',0,1,@NextAlertNum) WITH NOWAIT;
				BREAK;
			END
			

			-- Setting up alert configuration information!
				SET @AlertFreqSec = CONVERT(int,@AlertFreq)

			-- Get execution information!
			SELECT 
				@AlertLastRun = AEC.LastRun
				,@AlertLastResult = AEC.LastResult
			FROM 
				core.AlertExecutionControl AEC
			WHERE
				AEC.AlertID = @AlertID

			-- Validate last run of alert...
				IF @AlertLastRun IS NULL
				BEGIN
					-- If alert nevers ran, then create a new entry for it on control table...
					SET @AlertLastRun = GETDATE()
					INSERT INTO core.AlertExecutionControl(AlertID,LastRun) 
					VALUES(@AlertID,@AlertLastRun)
				END ELSE
					-- If last run not expired... 
					IF DATEDIFF(SS,@AlertLastRun,GETDATE()) <= @AlertFreqSec
					BEGIN
						IF @Debug = 1 RAISERROR('Skiping execution of alert %s because frequency. LastRun: %s , FreqSec: %s',0,1,@AlertName,@AlertLastRun,@AlertFreqSec)
						CONTINUE;
					END


			-- Time to Execute the Alert procedure!!!

				-- First build the input param XML!
				SET @AlertInput = (
					SELECT 
						@AlertID as '@id'
					FOR XML PATH('ap')
				)

				--	First, update the last run timestamp!
				UPDATE core.AlertExecutionControl SET LastRun = GETDATE() WHERE AlertID = @AlertID;
				
				IF @CatchErrors = 1 -- If catch errors was choosen, then run inside try..catch block to bypass possible errors...
					BEGIN TRY
						-- Now, let procedure take control over the execution!!!!!
						EXEC @AlertResult = @AlertProc @AlertInput,@AlertOutput OUTPUT
					END TRY
					BEGIN CATCH
						-- If some error ocurred, store in out control table...
						SET @ErrorXML = (
								SELECT
										 Number			= ERROR_NUMBER()
										,Message		= ERROR_MESSAGE()
										,ProcedureName	= ERROR_PROCEDURE()
										,Timestamp		= CURRENT_TIMESTAMP
										,ErrorLine		= ERROR_LINE()
								FOR XML RAW('error'),ELEMENTS
						)

						-- update the control table with the error data!
						UPDATE 
							core.AlertExecutionControl
						SET
							LastError = @ErrorXML
						WHERE
							AlertID = @AlertID;

						IF @Debug = 1
							RAISERROR('Last execution of alert %s, procedure %s resulted in error. Check error table',0,1,@AlertName,@AlertProc) WITH NOWAIT;

						CONTINUE;
					END CATCH
				ELSE BEGIN
					-- If ran without catch errors, just run...
					-- Now, let procedure take control over the execution!!!!!
					EXEC @AlertResult = @AlertProc @AlertInput,@AlertOutput OUTPUT
					IF @@ERROR != 0 RETURN;
				END
			
		-- NOW, WE HAVE SOME RESULT AND OUTPUT GENERATED BY THE ALERT PROCEDURE
		-- ITS TIME TO HANDLE THIS RESULT...

			-- Lets do some logging, if debug enabled!
			IF @Debug = 1
			BEGIN
				SET @TmpString = 'Alert '+ISNULL(@AlertName,'?')+' run successfuly. Proc = '+ISNULL(@AlertProc,'?')+' Result = '+ISNULL(CONVERT(varchar,@AlertResult),'?')
						+CHAR(13)+CHAR(10)+'Last Result:'+ISNULL(CONVERT(varchar,@AlertLastResult),'?')
						+CHAR(13)+CHAR(10)+'Output:'
						+CHAR(13)+CHAR(10)+ISNULL(CONVERT(nvarchar(max),@AlertOutput),'-- NULL OUTPUT --')
				RAISERROR(@TmpString,0,1) WITH NOWAIT;
			END

			-- Get the output proc for current alert!
			SELECT @OutputProc =  value FROM core.GetAlertParameters(@AlertID,NULL)
			WHERE name = 'OutputProc'

			IF OBJECT_ID(@OutputProc) IS NULL
				SET @OutputProc = NULL

			-- We do some action only if Result changed from last execution...
			IF (ISNULL(@AlertLastResult,0) = 0 AND @AlertResult = 1)	--> This test if a ALERT was generated (CLEAR -> ALERT)
					OR
				(@AlertLastResult = 1 AND @AlertResult = 0)				--> This test if a ALERT was claread (ALERT -> CLEAR)
			BEGIN

				--> First, is update the execution control table with new status!
				UPDATE core.AlertExecutionControl
				SET LastResult = @AlertResult,LastResultChange = GETDATE()
				WHERE AlertID = @AlertID

				-- Now, lets run the outputproc!
				-- This proc will handle the result generated by alert!
				-- TODO: Put outputproc insnide try catch and create a output log table!
				IF @Debug = 1 RAISERROR('Running outputproc %s for alert %s',0,1,@OutputProc,@AlertName) WITH NOWAIT;
				EXEC @OutputProc @AlertID,@AlertResult,@AlertOutput
			END


		END

		-- Sleep or ends loop!
		IF @SleepInterval IS NULL
			BREAK;
		ELSE BEGIN
			WAITFOR DELAY @SleepInterval	

			IF @@ERROR != 0 BREAK;
		END
	END




	


